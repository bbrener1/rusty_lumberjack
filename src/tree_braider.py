### Infinite Hidden Markov Model for clustering together tree nodes generated by Random Forests

import numpy as np
import random
# import pymc3 as pm
from functools import reduce
from scipy.misc import comb as nCk
from tree_reader import Node as TreeReaderNode

from scipy.special import logit,expit
from scipy.special import gamma as gamma_f

class IHMM:
    def __init__(self,forest,alpha=1,beta=1,gamma=1,alpha_e=.5,beta_e=.5,gamma_e=.5,start_states=20):

        self.forest = forest

        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma

        self.alpha_e = alpha_e
        self.beta_e = beta_e
        self.gamma_e = gamma_e

        self.start_states = 20

        self.hidden_states = []
        self.hidden_states.append(HiddenState.null(self))
        self.hidden_states.append(HiddenState.oracle(self))

        node_states = np.zeros(len(self.forest.nodes()),dtype=int)

        for node in self.forest.nodes():
            node.hidden_state = 0

        self.nodes = forest.roots() + forest.stems()

        for node in self.nodes:
            node.hidden_state = random.randint(1,self.start_states)
            node_states[node.index] = node.hidden_state

        self.total_samples = len(forest.samples)
        self.total_nodes = len(forest.nodes())

        self.divergence_masks = np.zeros((self.total_nodes,self.total_samples,2),dtype=bool)
        self.node_states = node_states
        self.oracle_indicator = np.ones(start_states+2)

        for node in self.nodes:
            # node.hidden_state = 1
            left,right = node.lr_encoding_vectors()
            self.divergence_masks[node.index,:,0] = left
            self.divergence_masks[node.index,:,1] = right

        print("INITIAL HIDDEN STATES")
        print([hs.index for hs in self.hidden_states])

        self.recompute_states(self.node_states)
        self.recompute_transition_matrix()
        self.recompute_oracle_indicator()
        self.resample_alpha_beta_prior()
        self.resample_gamma_prior()
        self.recompute_transition_odds()

    def resample_alpha_beta_prior(self):

        k = len(self.hidden_states)

        sums = np.sum(self.transition_matrix,axis=1)

        log_sequence = np.log2(np.arange(1,np.max(sums)))

        likelihood_sequence = np.zeros(log_sequence.shape)

        for i,state in enumerate(self.hidden_states):
            transitions = self.transition_matrix[i]
            total = int(np.sum(transitions))
            non_zero = int(np.sum(transitions > 1))
            l2ls = np.vectorize(lambda b: non_zero * log_sequence[b] - np.sum(log_sequence[b:total]))
            likelihood_sequence += l2ls(np.arange(log_sequence.shape[0],dtype=int))

        self.beta = np.argmax(likelihood_sequence)+1


    def resample_gamma_prior(self):

        oracle_total = int(np.sum(self.oracle_indicator) - self.gamma)

        log_sequence = np.log2(np.arange(oracle_total,oracle_total*2))

        k = len(self.hidden_states)

        l2l = np.vectorize(lambda g: k * np.log2(g) - np.sum(log_sequence[g:oracle_total+g]))

        likelihood_sequence = l2l(np.arange(1,log_sequence.shape[0],dtype=int))

        self.gamma = np.argmax(likelihood_sequence)+1

        pass

    def recompute_transition_matrix(self):

        new_transition_matrix = np.ones((len(self.hidden_states),len(self.hidden_states)))

        for i,state in enumerate(self.hidden_states):
            node_state = i
            for node in state.nodes:
                if node.parent is not None:
                    parent_state = node.parent.hidden_state
                    new_transition_matrix[node_state,parent_state] += 1
                else:
                    new_transition_matrix[node_state,0] += 1
                for child in node.children:
                    child_state = child.hidden_state
                    new_transition_matrix[child_state,node_state] += 1

        self.transition_matrix = new_transition_matrix
        self.total_transitions = np.sum(new_transition_matrix)

        # print("Recomputed Transition Matrix")
        # print(self.transition_matrix)

    def recompute_oracle_indicator(self):

        oracle_indicator = self.oracle_indicator

        # oracle_indicator[1] = 1

        oracle_transition_log_odds = odds_to_log_odds(oracle_indicator)

        new_oracle_indicator = np.ones(len(self.hidden_states))

        for i,s1 in enumerate(self.hidden_states):

            state_oracle_log_odds = np.log2(self.beta / (np.sum(self.transition_matrix[i])))

            log_odds_oracle_given_state = oracle_transition_log_odds + state_oracle_log_odds

            odds_oracle_given_state = np.exp2(log_odds_oracle_given_state)

            probability_oracle_given_state = odds_to_probability(odds_oracle_given_state)

            for j,s2 in enumerate(self.hidden_states):

                total_transitions = self.transition_matrix[i,j]

                new_oracle_indicator[i] += np.random.binomial(total_transitions,probability_oracle_given_state[j])

        new_oracle_indicator[1] = self.gamma

        self.oracle_indicator = new_oracle_indicator

        pass

    def recompute_transition_odds(self):

        transition_log_odds = np.zeros(self.transition_matrix.shape)

        oracle_state_log_odds = odds_to_log_odds(self.oracle_indicator)

        for i,state in enumerate(self.hidden_states):

            transitions = self.transition_matrix[i]

            direct_log_odds = odds_to_log_odds(transitions)

            transition_log_odds[i] += direct_log_odds

            oracle_log_odds = self.beta / np.sum(transitions)

            transition_log_odds[i] += (oracle_state_log_odds - oracle_log_odds)

        self.transition_odds = transition_log_odds


    def recompute_states(self,state_assignments):

        # print("All assignments")
        # print(state_assignments)
        # print("set")
        # print(sorted(list(set(state_assignments))))

        new_states = self.hidden_states[:2]
        new_state_map = [0,1]

        for state in sorted(list(set(state_assignments))):
            if (state != 0) and (state != 1):
                new_state_map.append(state)

        print(new_state_map)

        new_state_reverse_map = {state:i for i,state in enumerate(new_state_map)}

        print(new_state_reverse_map)

        new_states = new_states + [HiddenState(self,[],i + 2) for i in range(len(new_state_map[2:]))]

        # print(len(new_state_reverse_map))
        #
        print("BLANK HIDDEN STATES")
        print([ns.index for ns in new_states])

        node_assignments = [[] for new_state in new_states]

        for node in self.nodes:
            assignment = state_assignments[node.index]
            # print("TN:")
            # print(assignment)
            # print(new_state_reverse_map[assignment])
            node_assignments[new_state_reverse_map[assignment]].append(node)

        if len(node_assignments[1]) > 0:
            new_states.append(HiddenState(self,[],len(new_states)))
            node_assignments.append(node_assignments[1])
            node_assignments[1] = []

        for state,nodes in zip(new_states,node_assignments):
            state.assign_nodes(nodes)
        for state in new_states:
            state.recalculate_local_log_odds()

        print("HIDDEN STATES REASSIGNED 2")
        print([ns.index for ns in new_states])
        print([len(ns.nodes) for ns in new_states])

        self.hidden_states = new_states

        new_oracle_indicator = np.ones(len(self.hidden_states))

        for state,i in new_state_reverse_map.items():
            new_oracle_indicator[i] = self.oracle_indicator[state]

        self.oracle_indicator = new_oracle_indicator

        # print("HIDDEN STATES MEMORIZED")
        # print([hs.index for hs in self.hidden_states])
        #
        # print("All nodes")
        # print([n.hidden_state for n in self.nodes])


    def sample_states(self):

        resampled_states = self.node_states

        for node in self.nodes:
            resampled_states[node.index] = self.sample_node_state(node)

        self.recompute_states(resampled_states)

        self.recompute_transition_matrix()

        self.recompute_oracle_indicator()

        self.resample_alpha_beta_prior()

        self.resample_gamma_prior()

        self.recompute_transition_odds()


    def sample_node_slice(self,k):

        resampled_states = self.node_states

        resampled_nodes = random.sample(self.nodes,k)

        for node in resampled_nodes:
            resampled_states[node.index] = self.sample_node_state(node)

        self.recompute_states(resampled_states)

        self.recompute_transition_matrix()

        self.recompute_oracle_indicator()

        self.resample_alpha_beta_prior()

        self.resample_gamma_prior()

        self.recompute_transition_odds()

    def sample_node_state(self,node):
        # print("Sampling node state")
        parent,children,divergence = self.node_description(node)
        state_log_odds = np.zeros(len(self.hidden_states))
        # print(state_log_odds)
        for i,state in enumerate(self.hidden_states):
            state_log_odds[i] = state.log_odds(parent,children,divergence)
        # print(state_log_odds)
        state_odds = np.exp2(state_log_odds)
        # print(state_odds)
        new_state = random.choices(self.hidden_states,weights=state_odds)[0]
        # print(new_state)

        return new_state.index

    def node_description(self,node):
        parent = 0
        if node.parent is not None:
            parent = node.parent.hidden_state
        child_states = [0,0]
        for i,child in enumerate(node.children):
            child_states[i] = child.hidden_state
        divergence = (self.divergence_masks[node.index,:,0],self.divergence_masks[node.index,:,1])
        return parent,child_states,divergence


class HiddenState:



    def __init__(self,model,nodes,index):

        self.ihmm = model

        self.index = index

        self.nodes = nodes

        samples = len(self.ihmm.forest.samples)

        self.sample_log_odds = np.zeros(samples)

        self.odds_valid = False

    def null(model):
        return NullState(model)

    def oracle(model):
        return OracleState(model)


    def lr_finite(self):
        return expit(self.sample_log_odds)

    def log_odds_given_parent(self,parent_state):
        # transitions = self.ihmm.parent_transition_matrix[parent_state]
        # to_self = transitions[self.index]
        # to_other = np.sum(transitions) - to_self
        # log_odds = np.log2(to_self/to_other)
        # return log_odds
        return 0

    # def log_odds_given_child(self,child_state):
    #     transitions = self.ihmm.transition_matrix[child_state]
    #     to_self = transitions[self.index]
    #     to_other = np.sum(transitions) - to_self
    #     log_odds = np.log2(to_self/to_other)
    #     return log_odds

    def log_odds_given_child(self,child_state):

        return self.ihmm.transition_odds[child_state,self.index]

    def log_odds_given_divergence(self,divergence):

        dl,dr = divergence

        ls = np.sum(self.sample_log_odds[dl])
        rs = np.sum(self.sample_log_odds[dr])

        return max((ls - rs),(rs -ls))

    def best_vector(self,divergence):

        dl,dr = divergence

        ls = np.sum(self.sample_log_odds[dl])
        rs = np.sum(self.sample_log_odds[dr])

        if (ls - rs) > (rs - ls):
            return 0
        else:
            return 1

    def log_odds(self,parent_state,children,divergence):
        log_odds = 0
        log_odds += self.log_odds_given_parent(parent_state)
        for child in children:
            log_odds += self.log_odds_given_child(child)
        log_odds += self.log_odds_given_divergence(divergence)
        return log_odds

    def remove_nodes(self,nodes):
        for node in nodes:
            ni = self.nodes.index(node)
            self.nodes.pop(ni)
        self.odds_valid = False

    def clear_nodes(self):
        self.nodes = []
        self.odds_valid = False

    def assign_nodes(self,nodes):
        self.nodes = self.nodes + nodes
        for node in self.nodes:
            node.hidden_state = self.index
            self.ihmm.node_states[node.index] = self.index
        self.odds_valid = False

    def recalculate_local_log_odds(self):
        left = self.ihmm.alpha_e * np.ones(self.sample_log_odds.shape)
        right = (self.ihmm.beta_e + self.ihmm.alpha_e) * np.ones(self.sample_log_odds.shape)
        for node in self.nodes:
            _,_,divergence = self.ihmm.node_description(node)
            flip = self.best_vector(divergence)
            if flip:
                divergence = [divergence[1],divergence[0]]
            left += divergence[0]
            right += divergence[1]
        total = left + right
        new_log_odds = np.log2((left/total)/(right/total))
        self.sample_log_odds = new_log_odds
        self.odds_valid = True

    def node_mask(self):
        node_mask = np.zeros(len(self.ihmm.nodes),dtype=bool)
        for node in self.nodes:
            node_mask[node.index] = True
        return node_mask

    def node_odds(self):
        if not self.odds_valid:
            self.recalculate_local_log_odds()
        odds = []
        for node in self.nodes:
            odds.append(self.log_odds(*self.ihmm.node_description(node)))
        return odds

class NullState(HiddenState):

    def __init__(self,model):

        self.ihmm = model

        self.index = 0

        self.nodes = []

        samples = len(self.ihmm.forest.samples)

        self.sample_log_odds = np.zeros(samples)

    def assign_nodes(self,nodes):
        if len(nodes) > 0:
            raise Exception("Assigned null state to a node!")

    def log_odds(self,parent_state,children,divergence):

        return float('-inf')

class OracleState(HiddenState):

    def __init__(self,model):

        self.ihmm = model

        self.index = 1

        self.nodes = []

        samples = len(self.ihmm.forest.samples)

        self.sample_log_odds = np.zeros(samples)

    def assign_nodes(self,nodes):
        self.nodes = self.nodes + nodes
        for node in self.nodes:
            node.hidden_state = self.index
            self.ihmm.node_states[node.index] = self.index

    def log_odds_given_child(self,child_state):
        transitions = self.ihmm.transition_matrix[child_state]
        total = np.sum(transitions)
        # print("Oracle Debug")
        # print(transitions)
        # print(total)

        log_odds_oracle = np.log2(self.ihmm.beta / (1 + total + self.ihmm.alpha))

        log_odds_given_oracle = np.log2(self.ihmm.gamma / np.sum(self.ihmm.oracle_indicator))

        return log_odds_oracle + log_odds_given_oracle

    def log_odds(self,parent_state,children,divergence):
        log_odds = 0
        for child in children:
            log_odds += self.log_odds_given_child(child)
        return log_odds



def draw_beta_binomial(n,a,b):
    beta_draw = np.random.beta()
    binomial_draw = np.random.binomial(n,beta_draw)
    return binomial_draw


def odds_to_log_odds(odds):
    sum = np.sum(odds)
    counter_odds = sum - odds
    return np.log2(odds/counter_odds)

def odds_to_probability(odds):
    sum = np.sum(odds)
    return odds/sum
##

def stirling_falling_factorial(a,b):
    sequence = np.arange(min(a,b),max(a,b))
    log_sequence = np.log2(sequence)
    return np.sum(log_sequence)

def stirling_gamma(a):
    sequence = np.arange(1,a)
    log_sequence = np.log2(sequence)
    return np.sum(log_sequence)
