### Infinite Hidden Markov Model for clustering together tree nodes generated by Random Forests

import numpy as np
import random
# import pymc3 as pm
from functools import reduce
from scipy.misc import comb as nCk
from tree_reader import Node as TreeReaderNode

from scipy.special import logit,expit
from scipy.special import gamma as gamma_f

class IHMM:
    def __init__(self,forest,alpha=1,beta=1,gamma=1,alpha_e=.5,beta_e=.5,gamma_e=.5,start_states=20):

        self.forest = forest

        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma

        self.alpha_e = alpha_e
        self.beta_e = beta_e
        self.gamma_e = gamma_e

        self.start_states = 20

        self.hidden_states = []
        self.hidden_states.append(HiddenState.null(self))
        self.hidden_states.append(HiddenState.oracle(self))

        node_states = np.zeros(len(self.forest.nodes()),dtype=int)

        for node in self.forest.nodes():
            node.hidden_state = 0

        self.nodes = forest.roots() + forest.stems()

        for node in self.nodes:
            node.hidden_state = random.randint(1,self.start_states)
            node_states[node.index] = node.hidden_state

        self.total_samples = len(forest.samples)
        self.total_nodes = len(forest.nodes())

        self.divergence_masks = np.zeros((self.total_nodes,self.total_samples,2),dtype=bool)
        self.node_states = node_states
        self.oracle_indicator = np.ones(start_states+2)

        for node in self.nodes:
            # node.hidden_state = 1
            left,right = node.lr_encoding_vectors()
            self.divergence_masks[node.index,:,0] = left
            self.divergence_masks[node.index,:,1] = right

        print("INITIAL HIDDEN STATES")
        print([hs.index for hs in self.hidden_states])

        self.recompute_states(self.node_states)
        self.recompute_transition_matrix()
        self.recompute_oracle_indicator()
        self.establish_alpha_beta_prior()
        self.resample_gamma_prior()

    def establish_alpha_beta_prior(self):

        # self_transition = self.transition_matrix[np.identity(self.transition_matrix.shape[0],dtype=bool)]
        # self.alpha = np.mean(self_transition)

        self.beta = np.mean(self.transition_matrix)

    # def resample_alpha_beta_prior(self):
    #
    #     alpha = self.alpha
    #     beta = self.beta
    #
    #     log_scaling_factor = 0
    #
    #     for state in self.hidden_states:
    #         transitions = self.transition_matrix[state.index]
    #         non_zero_transitions = np.sum(transitions > 1)
    #
    #         first_log_scaling_factor = non_zero_transitions * np.log2(beta)
    #
    #         stirling_numerator = stirling_falling_factorial(alpha + beta, alpha)
    #         stirling_denomenator = stirling_falling_factorial(np.sum(transitions),transitions[state.index])
    #
    #         log_scaling_factor += first_log_scaling_factor
    #         log_scaling_factor += stirling_numerator
    #         log_scaling_factor -= stirling_denomenator
    #
    #     linear_scaling_factor = np.exp2(log_scaling_factor)
    #
    #     print("Log a/b scaling_factor")
    #     print(log_scaling_factor)
    #
    #     print("Recomputed a/b scale")
    #     print(linear_scaling_factor)
    #
    #     self.alpha = np.random.gamma(1,1/linear_scaling_factor)
    #     self.beta = np.random.gamma(1,1/linear_scaling_factor)

    # def resample_alpha_beta_prior(self):
    #
    #     alpha = self.alpha
    #     beta = self.beta
    #
    #     log_scaling_factor = 0
    #
    #     for state in self.hidden_states:
    #         transitions = self.transition_matrix[state.index]
    #         non_zero_transitions = np.sum(transitions > 1)
    #
    #         first_log_scaling_factor = non_zero_transitions * np.log2(beta)
    #
    #         stirling_numerator = stirling_gamma(alpha + beta) + stirling_gamma(transitions[state.index])
    #
    #         stirling_denomenator = stirling_gamma(np.sum(transitions)) + stirling_gamma(alpha)
    #
    #         log_scaling_factor += first_log_scaling_factor
    #         log_scaling_factor += stirling_numerator
    #         log_scaling_factor -= stirling_denomenator
    #
    #     linear_scaling_factor = np.exp2(log_scaling_factor)
    #
    #     print("Log a/b scaling_factor")
    #     print(log_scaling_factor)
    #
    #     print("Recomputed a/b scale")
    #     print(linear_scaling_factor)
    #
    #     self.alpha = np.random.gamma(1,1/linear_scaling_factor)
    #     self.beta = np.random.gamma(1,1/linear_scaling_factor)

    def resample_alpha_beta_prior(self):

        # alpha = self.alpha
        beta = self.beta

        # self_transition = self.transition_matrix[np.identity(self.transition_matrix.shape[0],dtype=bool)]
        # alpha_scale = np.mean(self_transition)

        beta_scale = np.sum(self.oracle_indicator) / len(self.oracle_indicator)

        print("Recomputed a/b scale")
        # print(alpha_scale)
        print(beta_scale)

        # self.alpha = np.random.gamma(1,alpha_scale)
        self.beta = np.random.gamma(1,beta_scale)


    # def resample_gamma_prior(self):
    #
    #     gamma = self.gamma
    #
    #     log_numerator = len(self.hidden_states) * np.log2(gamma)
    #     stirling_denomenator = stirling_falling_factorial(np.sum(self.oracle_indicator) + gamma, gamma)
    #
    #     log_scaling_factor = log_numerator - stirling_denomenator
    #
    #     print("Log g scaling_factor")
    #     print(log_scaling_factor)
    #
    #     scaling_factor = np.exp2(log_scaling_factor)
    #
    #     print("Recomputed g scale")
    #     print(scaling_factor)
    #
    #     self.gamma = np.random.gamma(1,1/scaling_factor)

    def resample_gamma_prior(self):

        gamma = self.gamma

        oracle_total = np.sum(self.oracle_indicator)

        self.gamma = np.random.gamma(1,oracle_total / len(self.hidden_states))

    def recompute_transition_matrix(self):

        new_transition_matrix = np.ones((len(self.hidden_states),len(self.hidden_states)))
        new_transition_matrix[np.identity(len(self.hidden_states),dtype=bool)] += self.alpha
        new_transition_matrix[:,1] += self.gamma

        for i,state in enumerate(self.hidden_states):
            node_state = i
            for node in state.nodes:
                if node.parent is not None:
                    parent_state = node.parent.hidden_state
                    new_transition_matrix[node_state,parent_state] += 1
                else:
                    new_transition_matrix[node_state,0] += 1
                for child in node.children:
                    child_state = child.hidden_state
                    new_transition_matrix[child_state,node_state] += 1

        self.transition_matrix = new_transition_matrix
        self.total_transitions = np.sum(new_transition_matrix)

        # print("Recomputed Transition Matrix")
        # print(self.transition_matrix)

    def recompute_oracle_indicator(self):

        oracle_transition_log_odds = self.oracle_indicator

        new_oracle_indicator = np.ones(len(self.hidden_states))

        for i,s1 in enumerate(self.hidden_states):

            state_oracle_log_odds = np.log2(self.beta / (np.sum(self.transition_matrix[i])))

            log_odds_oracle_given_state = oracle_transition_log_odds + state_oracle_log_odds

            odds_oracle_given_state = np.exp2(log_odds_oracle_given_state)

            probability_oracle_given_state = odds_to_probability(odds_oracle_given_state)

            for j,s2 in enumerate(self.hidden_states):

                total_transitions = self.transition_matrix[i,j]

                new_oracle_indicator[i] += np.random.binomial(total_transitions,probability_oracle_given_state[j])

        self.oracle_indicator = new_oracle_indicator

        pass

    def recompute_states(self,state_assignments):

        # print("All assignments")
        # print(state_assignments)
        # print("set")
        # print(sorted(list(set(state_assignments))))

        new_states = self.hidden_states[:2]
        new_state_map = [0,1]

        for state in sorted(list(set(state_assignments))):
            if (state != 0) and (state != 1):
                new_state_map.append(state)

        print(new_state_map)

        new_state_reverse_map = {state:i for i,state in enumerate(new_state_map)}

        print(new_state_reverse_map)

        new_states = new_states + [HiddenState(self,[],i + 2) for i in range(len(new_state_map[2:]))]

        # print(len(new_state_reverse_map))
        #
        # print("BLANK HIDDEN STATES")
        # print([ns.index for ns in new_states])

        node_assignments = [[] for new_state in new_states]

        for node in self.nodes:
            assignment = state_assignments[node.index]
            # print("TN:")
            # print(assignment)
            # print(new_state_reverse_map[assignment])
            node_assignments[new_state_reverse_map[assignment]].append(node)

        if len(node_assignments[1]) > 0:
            new_states.append(HiddenState(self,[],len(new_states)))
            node_assignments.append(node_assignments[1])
            node_assignments[1] = []

        for state,nodes in zip(new_states,node_assignments):
            state.assign_nodes(nodes)
        for state in new_states:
            state.recalculate_local_log_odds()

        # print("HIDDEN STATES REASSIGNED 2")
        # print([ns.index for ns in new_states])

        self.hidden_states = new_states

        # print("HIDDEN STATES MEMORIZED")
        # print([hs.index for hs in self.hidden_states])
        #
        # print("All nodes")
        # print([n.hidden_state for n in self.nodes])


    def sample_states(self):

        resampled_states = self.node_states

        for node in self.nodes:
            resampled_states[node.index] = self.sample_node_state(node)

        self.recompute_states(resampled_states)

        self.recompute_transition_matrix()

        self.recompute_oracle_indicator()

        self.resample_alpha_beta_prior()

        self.resample_gamma_prior()


    def sample_node_slice(self,k):

        resampled_states = self.node_states

        resampled_nodes = random.sample(self.nodes,k)

        for node in resampled_nodes:
            resampled_states[node.index] = self.sample_node_state(node)

        self.recompute_states(resampled_states)

        self.recompute_transition_matrix()

        self.recompute_oracle_indicator()

        self.resample_alpha_beta_prior()

        self.resample_gamma_prior()

    def sample_node_state(self,node):
        # print("Sampling node state")
        parent,children,divergence = self.node_description(node)
        state_log_odds = np.zeros(len(self.hidden_states))
        # print(state_log_odds)
        for i,state in enumerate(self.hidden_states):
            state_log_odds[i] = state.log_odds(parent,children,divergence)
        # print(state_log_odds)
        state_odds = np.exp2(state_log_odds)
        # print(state_odds)
        new_state = random.choices(self.hidden_states,weights=state_odds)[0]
        # print(new_state)

        return new_state.index

    def node_description(self,node):
        parent = 0
        if node.parent is not None:
            parent = node.parent.hidden_state
        child_states = [0,0]
        for i,child in enumerate(node.children):
            child_states[i] = child.hidden_state
        divergence = (self.divergence_masks[node.index,:,0],self.divergence_masks[node.index,:,1])
        return parent,child_states,divergence


class HiddenState:



    def __init__(self,model,nodes,index):

        self.ihmm = model

        self.index = index

        self.nodes = nodes

        samples = len(self.ihmm.forest.samples)

        self.sample_log_odds = np.zeros(samples)

        self.odds_valid = False

    def null(model):
        return NullState(model)

    def oracle(model):
        return OracleState(model)

    def lr_finite(self):
        return expit(self.sample_log_odds)

    def log_odds_given_parent(self,parent_state):
        # transitions = self.ihmm.parent_transition_matrix[parent_state]
        # to_self = transitions[self.index]
        # to_other = np.sum(transitions) - to_self
        # log_odds = np.log2(to_self/to_other)
        # return log_odds
        return 0

    def log_odds_given_child(self,child_state):
        transitions = self.ihmm.transition_matrix[child_state]
        to_self = transitions[self.index]
        to_other = np.sum(transitions) - to_self
        log_odds = np.log2(to_self/to_other)
        return log_odds

    def log_odds_given_divergence(self,divergence):

        dl,dr = divergence

        ls = np.sum(self.sample_log_odds[dl])
        rs = np.sum(self.sample_log_odds[dr])

        return max((ls - rs),(rs -ls))

    def best_vector(self,divergence):

        dl,dr = divergence

        ls = np.sum(self.sample_log_odds[dl])
        rs = np.sum(self.sample_log_odds[dr])

        if (ls - rs) > (rs - ls):
            return 0
        else:
            return 1

    def log_odds(self,parent_state,children,divergence):
        log_odds = 0
        log_odds += self.log_odds_given_parent(parent_state)
        for child in children:
            log_odds += self.log_odds_given_child(child)
        log_odds += self.log_odds_given_divergence(divergence)
        return log_odds

    def remove_nodes(self,nodes):
        for node in nodes:
            ni = self.nodes.index(node)
            self.nodes.pop(ni)
        self.odds_valid = False

    def clear_nodes(self):
        self.nodes = []
        self.odds_valid = False

    def assign_nodes(self,nodes):
        self.nodes = self.nodes + nodes
        for node in self.nodes:
            node.hidden_state = self.index
            self.ihmm.node_states[node.index] = self.index
        self.odds_valid = False

    def recalculate_local_log_odds(self):
        left = self.ihmm.alpha_e * np.ones(self.sample_log_odds.shape)
        right = (self.ihmm.beta_e + self.ihmm.alpha_e) * np.ones(self.sample_log_odds.shape)
        for node in self.nodes:
            _,_,divergence = self.ihmm.node_description(node)
            flip = self.best_vector(divergence)
            if flip:
                divergence = [divergence[1],divergence[0]]
            left += divergence[0]
            right += divergence[1]
        total = left + right
        new_log_odds = np.log2((left/total)/(right/total))
        self.sample_log_odds = new_log_odds
        self.odds_valid = True

    def node_mask(self):
        node_mask = np.zeros(len(self.ihmm.nodes),dtype=bool)
        for node in self.nodes:
            node_mask[node.index] = True
        return node_mask

    def node_odds(self):
        if not self.odds_valid:
            self.recalculate_local_log_odds()
        odds = []
        for node in self.nodes:
            odds.append(self.log_odds(*self.ihmm.node_description(node)))
        return odds

class NullState(HiddenState):

    def __init__(self,model):

        self.ihmm = model

        self.index = 0

        self.nodes = []

        samples = len(self.ihmm.forest.samples)

        self.sample_log_odds = np.zeros(samples)

    def assign_nodes(self,nodes):
        if len(nodes) > 0:
            raise Exception("Assigned null state to a node!")

    def log_odds(self,parent_state,children,divergence):

        return float('-inf')

class OracleState(HiddenState):

    def __init__(self,model):

        self.ihmm = model

        self.index = 1

        self.nodes = []

        samples = len(self.ihmm.forest.samples)

        self.sample_log_odds = np.zeros(samples)

    def assign_nodes(self,nodes):
        self.nodes = self.nodes + nodes
        for node in self.nodes:
            node.hidden_state = self.index
            self.ihmm.node_states[node.index] = self.index

    def log_odds(self,parent_state,children,divergence):
        occurrence = self.ihmm.gamma
        total = self.ihmm.total_transitions + self.ihmm.gamma
        return np.log2(occurrence / total)



def draw_beta_binomial(n,a,b):
    beta_draw = np.random.beta()
    binomial_draw = np.random.binomial(n,beta_draw)
    return binomial_draw


def odds_to_log_odds(odds):
    sum = np.sum(odds)
    counter_odds = sum - odds
    return np.log2(odds/counter_odds)

def odds_to_probability(odds):
    sum = np.sum(odds)
    return odds/sum
##

def stirling_falling_factorial(a,b):
    sequence = np.arange(a,b)
    log_sequence = np.log2(sequence)
    return np.sum(log_sequence)

def stirling_gamma(a):
    sequence = np.arange(1,a)
    log_sequence = np.log2(sequence)
    return np.sum(log_sequence)
