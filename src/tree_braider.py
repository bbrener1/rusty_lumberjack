### Infinite Hidden Markov Model for clustering together tree nodes generated by Random Forests

import numpy as np
import random
# import pymc3 as pm
from functools import reduce
from scipy.misc import comb as nCk
from tree_reader import Node as TreeReaderNode

from scipy.special import logit,expit

class IHMM:
    def __init__(self,forest):

        self.forest = forest

        self.alpha = 1
        self.beta = 1
        self.gamma = 1

        self.alpha_e = 10
        self.beta_e = 10
        self.gamma_e = 1

        self.oracle_counter = 1

        self.hidden_state_counter = 1

        self.transition_model = None
        self.transition_oracle_model = None

        self.emission_model = None
        self.emission_oracle_model = None

        self.hidden_states = []
        self.hidden_states.append(HiddenState.null(self))
        self.hidden_states.append(HiddenState.oracle(self))

        self.nodes = forest.roots() + forest.stems()

        self.total_samples = len(forest.samples)
        self.total_nodes = len(forest.nodes())

        self.divergence_masks = np.zeros((self.total_nodes,self.total_samples,2),dtype=bool)
        self.node_states = np.zeros(total_nodes,dtype=int)

        for node in self.nodes:
            node.hidden_state = 1
            left,right = node.lr_encoding_vectors()
            self.divergence_masks[node.index,:,0] = left
            self.divergence_masks[node.index,:,1] = right



    def sample_states(self):

        resampled_states = {state: [] for state in self.hidden_states}

        for i,node in enumerate(self.nodes):
            resampled_states[self.sample_node_state(node)].append(node)

        for state,nodes in resampled_states.items():
            state.reassign_nodes(nodes)

    # def sample_node_slice(self):
    #
    #     resampled_states = {state: [] for state in self.hidden_states}
    #
    #     for i,node in enumerate(self.nodes):
    #         resampled_states[self.sample_node_state(node)].append(node)
    #
    #     for state,nodes in resampled_states.items():
    #         state.reassign_nodes(nodes)


    def sample_node_state(self,node):
        print("Sampling node state")
        parent,divergence = self.node_description(node)
        state_log_odds = np.zeros(len(self.hidden_states))
        print(state_log_odds)
        for i,state in enumerate(self.hidden_states):
            state_log_odds[i] = state.log_odds(parent,divergence)
        print(state_log_odds)
        state_odds = np.exp2(state_log_odds)
        print(state_odds)
        new_state = random.choices(self.hidden_states,weights=state_odds)[0]
        print(new_state)
        return new_state

    def node_description(self,node):
        parent = 0
        if node.parent is not None:
            parent = node.parent.hidden_state
        divergence = (self.divergence_masks[node.index,:,0],self.divergence_masks[node.index,:,1])
        return parent,divergence


class HiddenState:



    def __init__(self,model,nodes):

        ihmm.hidden_state_counter += 1

        self.ihmm = model

        self.index = self.ihmm.hidden_state_counter

        self.nodes = nodes

        samples = len(self.ihmm.forest.samples)

        self.sample_log_odds = np.zeros(samples)


    def null(model):
        return NullState(model)

    def oracle(model):
        return OracleState(model)

    def lr_finite(self):
        return expit(self.sample_log_odds)

    def log_odds_given_parent(self,parent_state):
        return 0

    def log_odds_given_divergence(self,divergence):

        dl,dr = divergence

        ls = np.sum(self.sample_log_odds[dl])
        rs = np.sum(self.sample_log_odds[dr])

        return max((ls - rs),(rs -ls))

    def log_odds_given_dp_prior(self):
        occurrence = len(self.nodes) + self.ihmm.gamma
        total = self.ihmm.total_nodes + (self.ihmm.gamma * len(self.ihmm.hidden_states - 1)) + self.ihmm.oracle_counter
        return np.log2(occurrence / total)

    def best_vector(self,divergence):

        dl,dr = divergence

        ls = np.sum(self.sample_log_odds[dl])
        rs = np.sum(self.sample_log_odds[dr])

        if (ls - rs) > (rs - ls):
            return 0
        else:
            return 1

    def log_odds(self,parent_state,divergence):
        log_odds = 0
        log_odds += self.log_odds_given_parent(parent_state)
        log_odds += self.log_odds_given_divergence(divergence)
        log_odds += self.log_odds_dp_prior()
        return log_odds

    def reassign_nodes(self,nodes):
        self.nodes = nodes
        for node in self.nodes:
            node.hidden_state = self.index
        self.recalculate_local_log_odds()

    def recalculate_local_log_odds(self):
        left = self.ihmm.alpha_e * np.ones(self.sample_log_odds.shape)
        right = self.ihmm.beta_e * np.ones(self.sample_log_odds.shape)
        for node in self.nodes:
            _,divergence = self.ihmm.node_description(node)
            flip = self.best_vector(divergence)
            if flip:
                divergence = [divergence[1],divergence[0]]
            left += divergence[0]
            right += divergence[1]
        total = left + right
        new_log_odds = np.log2((left/total)/(right/total))
        self.sample_log_odds = new_log_odds

    def node_mask(self):
        node_mask = np.zeros(len(self.ihmm.nodes),dtype=bool)
        for node in self.nodes:
            node_mask[node.index] = True
        return node_mask

    def node_odds(self):
        odds = []
        for node in self.nodes:
            odds.append(self.log_odds(*self.ihmm.node_description(node)))
        return odds

class NullState(HiddenState):

    def __init__(self,model):

        self.ihmm = model

        self.index = 0

        self.nodes = []

        samples = len(self.ihmm.forest.samples)

        self.sample_log_odds = np.zeros(samples)

    def reassign_nodes(self,nodes):
        if len(nodes) > 0:
            raise Exception("Assigned null state to a node!")

    def log_odds(self,parent_state,divergence):

        return float('-inf')

class OracleState(HiddenState):

    def __init__(self,model):

        self.ihmm = model

        self.index = 1

        self.nodes = []

        samples = len(self.ihmm.forest.samples)

        self.sample_log_odds = np.zeros(samples)

    def reassign_nodes(self,nodes):
        if len(nodes) > 0:
            self.ihmm.oracle_counter += 1
        new_state = HiddenState(self.ihmm,nodes,len(self.ihmm.hidden_states))
        self.ihmm.hidden_states.append(new_state)

    def log_odds(self,parent_state,divergence):

        return np.log2(self.ihmm.gamma / self.ihmm.total_nodes + (self.ihmm.gamma * len(self.ihmm.hidden_states)) + self.ihmm.oracle_counter
