### Infinite Hidden Markov Model for clustering together tree nodes generated by Random Forests

import numpy as np
# import pymc3 as pm
from functools import reduce

class IHMM:
    def __init__(self,forest):

        self.alpha = 1
        self.beta = 1
        self.gamma = 1

        self.beta_e = 1
        self.gamma_e = 1

        self.transition_model = None
        self.transition_oracle_model = None

        self.emission_model = None
        self.emission_oracle_model = None

        self.hidden_states = []
        self.hidden_states.append(HiddenState.null())
        self.hidden_states.append(HiddenState.oracle())

        self.nodes = forest.nodes()

        samples = len(forest.samples)

        self.divergence = np.zeros((len(self.nodes),samples,samples,2))

        for node in self.nodes:
            self.divergence[node.index] = node.sample_divergence_encoding()

        could_sum = np.sum(self.divergence[:,:,:,0],axis=0)
        did_sum = np.sum(self.divergence[:,:,:,1],axis=1)

        self.could = could_sum
        self.did = did_sum

        if np.any(could_sum < 1):
            print("WARNING:")
            print("Unrepresented sample divergences")
            print("Odds may be ill-defined")

        self.transition_matrix = np.zeros((len(self.nodes),len(self.nodes)))



        self.forest = forest

    def sample_states(self):

        resampled_states = []
        for i,node in enumerate(self.forest.nodes()):
            parent = node.parent.hidden_state
            children = [c.hidden_state for c in children]
            represented_samples = node.sample_mask()

            resampled_states.push(HiddenState.resample(node))

    def sample_node_state(node):
        state_priors = np.ones(len(self.hidden_state)+1)


class HiddenState:

    def __init__(model,nodes):

        self.ihmm = model

        self.nodes = nodes

        samples = len(self.ihmm.forest.samples)

        return self

    def resample(node):
        parent = node.parent

    def null():
        return NullState()

    def oracle():
        return OracleState()

    def log_odds_given_parent(self,parent_state):
        0

    def log_odds_given_child(self,child_state):
        0

    def log_odds_given_divergence(self,divergence):

        divergence = divergence.astype(dtype=bool)

        np.log_odds_ratio = np.log2(self.div_odds_ratio)

        did = np.logical_and(divergence[:,:,0],divergence[:,:,1])
        didnt = np.logical_and(divergence[:,:,0],np.logical_not(divergence[:,:,1]))

        log_odds_did = np.log2(self.div_odds_ratio[did])
        log_odds_didnt = np.log2(1 / self.div_odds_ratio[didnt])

        log_odds_did[np.isnan(log_odds_did)] = 0
        log_odds_didnt[np.isnan(log_odds_didnt)] = 0

        log_odds = np.sum(log_odds_did) + np.sum(log_odds_didnt)

        return log_odds

    def log_odds(self,parent_state,child_states,sample_mask,divergence):
        log_odds = 0
        log_odds += self.log_odds_given_parent(parent_state)
        for child_state in child_states:
            log_likelihood += self.log_likelihood_given_child(child_state)
        log_likelihood += self.log_likelihood_given_divergence(divergence)
        return log_likelihood

    def div_odds_ratio(self):
        node_mask = self.node_mask()
        in_cluster_could = np.sum(self.ihmm.divergence[node_mask][:,:,:,0],axis=0)
        in_cluster_did = np.sum(self.ihmm.divergence[node_mask][:,:,:,1],axis=1)
        outside_could = self.ihmm.could - in_cluster_could
        outside_did = self.ihmm.did - in_cluster_did
        div_odds_ratio = (in_cluster_did/in_cluster_could) / (outside_did/outside_could)
        div_odds_ratio[np.isnan(div_odds_ratio)] = 0
        self.div_odds_ratio = div_odds_ratio
        return div_odds_ratio

    def node_mask(self):
        node_mask = np.zeros(len(self.ihmm.nodes),dtype=bool)
        for node in self.nodes:
            node_mask[node.index] = True
        return node_mask

class NullState(HiddenState):

    def __init__(self,model):

        self.ihmm = model

        self.nodes = []

        samples = len(self.ihmm.forest.samples)

    def log_odds(self,parent_state,child_states,samples_mask,divergence):

        return float('-inf')

class OracleState(HiddenState):

    def __init__(self,model):

        self.ihmm = model

        self.nodes[]

        samples = len(self.ihmm.forest.samples)


    def log_odds(self,parent_state,child_states,samples_mask,divergence):

        0
