### Infinite Hidden Markov Model for clustering together tree nodes generated by Random Forests

import numpy as np
import random
# import pymc3 as pm
from functools import reduce
from scipy.misc import comb as nCk
from tree_reader import Node as TreeReaderNode

from scipy.special import logit,expit

class IHMM:
    def __init__(self,forest):

        self.forest = forest

        self.alpha = 1
        self.beta = 1
        self.gamma = 1

        self.alpha_e = 10
        self.beta_e = 10
        self.gamma_e = 10

        self.oracle_counter = 0

        self.transition_model = None
        self.transition_oracle_model = None

        self.emission_model = None
        self.emission_oracle_model = None

        self.hidden_states = []
        self.hidden_states.append(HiddenState.null(self))
        self.hidden_states.append(HiddenState.oracle(self))
        for i in range(20):
            self.hidden_states.append(HiddenState(self,[],i+2))

        for node in self.forest.nodes():
            node.hidden_state = 0

        self.nodes = forest.roots() + forest.stems()

        self.total_samples = len(forest.samples)
        self.total_nodes = len(forest.nodes())

        self.divergence_masks = np.zeros((self.total_nodes,self.total_samples,2),dtype=bool)
        self.node_states = np.zeros(self.total_nodes,dtype=int)

        for node in self.nodes:
            node.hidden_state = 1
            left,right = node.lr_encoding_vectors()
            self.divergence_masks[node.index,:,0] = left
            self.divergence_masks[node.index,:,1] = right

        self.recompute_transition_matrix()

    def recompute_transition_matrix(self):

        new_transition_matrix = self.beta * np.ones((len(self.hidden_states),len(self.hidden_states)))
        new_transition_matrix[np.identity(len(self.hidden_states),dtype=bool)] += self.alpha
        new_transition_matrix[:,1] += self.gamma

        for node in self.nodes:
            node_state = node.hidden_state
            if node.parent is not None:
                parent_state = node.parent.hidden_state
                new_transition_matrix[parent_state,node_state] += 1
            else:
                new_transition_matrix[0,node_state] += 1
            for child in node.children:
                child_state = child.hidden_state
                new_transition_matrix[node_state,child_state] += 1

        self.transition_matrix = new_transition_matrix

    def recompute_states(self,state_assignments):
        new_states = []
        new_state_dict = {}
        for i,state in enumerate(list(set(state_assignments))):
            new_states.append(HiddenState(self,[],i))
            new_state_dict[i] = state

        node_assignments = [[] for new_state in new_states]
        for i,assignment in state_assignments:
            node_assignments[new_state_dict[assignment]].push(self.nodes[i])

        for state,nodes in zip(new_states,node_assignments):
            state.assign_nodes()
            state.recalculate_local_log_odds()

        self.hidden_states = new_states

    def sample_states(self):

        resampled_states = {state: [] for state in self.hidden_states[1:]}

        for i,node in enumerate(self.nodes):
            resampled_states[self.sample_node_state(node)].append(node)

        for state,nodes in resampled_states.items():
            state.clear_nodes()
            index = self.hidden_states.index(state)
            print(index)
            print(len(nodes))
            if len(nodes) < 1:
                if index > 1:
                    print("Deleting")
                    print(index)
                    self.hidden_states.pop(self.hidden_states.index(state))

        for i,state in enumerate(self.hidden_states):
            state.index = i

        for state,nodes in resampled_states.items():
            state.assign_nodes(nodes)
            state.recalculate_local_log_odds()

        self.recompute_transition_matrix()


    def sample_node_slice(self,k):

        resampled_states = {state: [] for state in self.hidden_states}

        resampled_nodes = random.sample(self.nodes,k)

        for i,node in enumerate(resampled_nodes):
            node_state = self.hidden_states[node.hidden_state]
            node_state.remove_nodes([node])
            resampled_states[self.sample_node_state(node)].append(node)

        for state,nodes in resampled_states.items():
            state.assign_nodes(nodes)

        for state in self.hidden_states:
            index = self.hidden_states.index(state)
            print(index)
            print(len(nodes))
            if len(state.nodes) < 1:
                if index > 1:
                    print("Deleting")
                    print(index)
                    self.hidden_states.pop(self.hidden_states.index(state))


        for i,state in enumerate(self.hidden_states):
            state.index = i

        for state in self.hidden_states:
            state.recalculate_local_log_odds()

        self.recompute_transition_matrix()


    def sample_node_state(self,node):
        # print("Sampling node state")
        parent,divergence = self.node_description(node)
        state_log_odds = np.zeros(len(self.hidden_states))
        # print(state_log_odds)
        for i,state in enumerate(self.hidden_states):
            state_log_odds[i] = state.log_odds(parent,divergence)
        print(state_log_odds)
        state_odds = np.exp2(state_log_odds)
        # print(state_odds)
        new_state = random.choices(self.hidden_states,weights=state_odds)[0]
        print(new_state)
        return new_state

    def node_description(self,node):
        parent = 0
        if node.parent is not None:
            parent = node.parent.hidden_state
        divergence = (self.divergence_masks[node.index,:,0],self.divergence_masks[node.index,:,1])
        return parent,divergence


class HiddenState:



    def __init__(self,model,nodes,index):

        self.ihmm = model

        self.index = index

        self.nodes = nodes

        samples = len(self.ihmm.forest.samples)

        self.sample_log_odds = np.zeros(samples)

        self.odds_valid = False

    def null(model):
        return NullState(model)

    def oracle(model):
        return OracleState(model)

    def lr_finite(self):
        return expit(self.sample_log_odds)

    def log_odds_given_parent(self,parent_state):
        transitions = self.ihmm.transition_matrix[parent_state]
        to_self = transitions[self.index]
        to_other = np.sum(transitions) - to_self
        log_odds = np.log2(to_self/to_other)
        return log_odds

    def log_odds_given_divergence(self,divergence):

        dl,dr = divergence

        ls = np.sum(self.sample_log_odds[dl])
        rs = np.sum(self.sample_log_odds[dr])

        return max((ls - rs),(rs -ls))

    def log_odds_dp_prior(self):
        occurrence = len(self.nodes) + self.ihmm.gamma_e
        total = self.ihmm.total_nodes + (self.ihmm.gamma_e * (len(self.ihmm.hidden_states) - 1)) + self.ihmm.oracle_counter
        return np.log2(occurrence / total)

    def best_vector(self,divergence):

        dl,dr = divergence

        ls = np.sum(self.sample_log_odds[dl])
        rs = np.sum(self.sample_log_odds[dr])

        if (ls - rs) > (rs - ls):
            return 0
        else:
            return 1

    def log_odds(self,parent_state,divergence):
        log_odds = 0
        log_odds += self.log_odds_given_parent(parent_state)
        log_odds += self.log_odds_given_divergence(divergence)
        log_odds += self.log_odds_dp_prior()
        return log_odds

    def remove_nodes(self,nodes):
        for node in nodes:
            ni = self.nodes.index(node)
            self.nodes.pop(ni)
        self.odds_valid = False

    def clear_nodes(self):
        self.nodes = []
        self.odds_valid = False

    def assign_nodes(self,nodes):
        self.nodes = self.nodes + nodes
        for node in self.nodes:
            node.hidden_state = self.index
        self.odds_valid = False

    def recalculate_local_log_odds(self):
        left = self.ihmm.alpha_e * np.ones(self.sample_log_odds.shape)
        right = (self.ihmm.beta_e + self.ihmm.alpha_e) * np.ones(self.sample_log_odds.shape)
        for node in self.nodes:
            _,divergence = self.ihmm.node_description(node)
            flip = self.best_vector(divergence)
            if flip:
                divergence = [divergence[1],divergence[0]]
            left += divergence[0]
            right += divergence[1]
        total = left + right
        new_log_odds = np.log2((left/total)/(right/total))
        self.sample_log_odds = new_log_odds
        self.odds_valid = True

    def node_mask(self):
        node_mask = np.zeros(len(self.ihmm.nodes),dtype=bool)
        for node in self.nodes:
            node_mask[node.index] = True
        return node_mask

    def node_odds(self):
        if not self.odds_valid:
            self.recalculate_local_log_odds()
        odds = []
        for node in self.nodes:
            odds.append(self.log_odds(*self.ihmm.node_description(node)))
        return odds

class NullState(HiddenState):

    def __init__(self,model):

        self.ihmm = model

        self.index = 0

        self.nodes = []

        samples = len(self.ihmm.forest.samples)

        self.sample_log_odds = np.zeros(samples)

    def reassign_nodes(self,nodes):
        if len(nodes) > 0:
            raise Exception("Assigned null state to a node!")

    def log_odds(self,parent_state,divergence):

        return float('-inf')

class OracleState(HiddenState):

    def __init__(self,model):

        self.ihmm = model

        self.index = 1

        self.nodes = []

        samples = len(self.ihmm.forest.samples)

        self.sample_log_odds = np.zeros(samples)

    def reassign_nodes(self,nodes):
        self.ihmm.oracle_counter = len(nodes)
        if len(nodes) > 0:
            new_state = HiddenState(self.ihmm,[],len(self.ihmm.hidden_states))
            new_state.reassign_nodes(nodes)
            self.ihmm.hidden_states.append(new_state)

    def log_odds(self,parent_state,divergence):
        occurrence = self.ihmm.gamma_e + self.ihmm.oracle_counter
        total = (self.ihmm.gamma_e * len(self.ihmm.hidden_states)) + self.ihmm.oracle_counter + self.ihmm.total_nodes
        return np.log2(occurrence / total)
